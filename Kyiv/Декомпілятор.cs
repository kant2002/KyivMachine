using Система.Лінкью;
using static Kyiv.Конвертер;

namespace Kyiv;

public class Декомпілятор
{
    public static string Декомпілювати(string команда)
    {
        var лістінг = ПарсерЛістінга.ПрочитатиІзРядка(команда);
        return Декомпілювати(лістінг);
    }

    public static string Декомпілювати(Лістінг лістінг)
    {
        лістінг = НормалізуватиЛістінг(лістінг);
        лістінг = СпроститиКод(лістінг);

        var писарРядку = new StringWriter();
        using var писар = new ТекстовийПисарІзВиступами(писарРядку);
        foreach (var блокКоду in лістінг.БлокиКоду)
        {
            писар.WriteLine($"lbl_{До8РічноїАдреси(блокКоду.ПочатковаАдреса)}:");
            писар.Відступ++;
            foreach (var операція in блокКоду.Операції)
            {
                НадрукуватиОперацію(писар, операція);
            }

            писар.Відступ--;
        }

        return писарРядку.ToString();
    }

    private static Лістінг СпроститиКод(Лістінг лістінг)
    {
        foreach (var блокКоду in лістінг.БлокиКоду)
        {
            for (int i = 0; i < блокКоду.Операції.Count; i++)
            {
                var операція = блокКоду.Операції[i];
                блокКоду.Операції[i] = ВставитиЗмінні(операція);
            }
        }

        Лістінг результат = new();
        БлокКоду? останнійОбробленийБлокКоду = null;
        foreach (var блокКоду in лістінг.БлокиКоду)
        {
            БлокКоду новийБлокКоду;
            if (останнійОбробленийБлокКоду is not null 
                && останнійОбробленийБлокКоду.Операції.ОстанняАбоЗаЗамовчанням() is { } останняОбробленаОперація
                && останняОбробленаОперація is Перехід перехід
                && перехід.адреса == блокКоду.ПочатковаАдреса)
            {
                новийБлокКоду = останнійОбробленийБлокКоду;
                останнійОбробленийБлокКоду.Операції.Remove(останняОбробленаОперація);
            }
            else
            {
                новийБлокКоду = new БлокКоду(блокКоду.ПочатковаАдреса);
                результат.БлокиКоду.Add(новийБлокКоду);
            }

            var кінецьЦиклуЗнайден = false;
            for (int i = 0; i < блокКоду.Операції.Count; i++)
            {
                var операція = блокКоду.Операції[i];
                if (операція is ЗберіганняЗмінної зберіганняЦ && зберіганняЦ.МісцеЗберігання is Регістр { регістр: ТипРегістра.Ц })
                {
                    var зберіганняА = (ЗберіганняЗмінної)блокКоду.Операції[i + 1];
                    var ц = ((Константа)зберіганняЦ.Що).значення;
                    var а = ((Константа)зберіганняА.Що).значення;
                    if (ц == а)
                    {
                        var умовнаОперація = (УмовнаОперація)блокКоду.Операції[i + 2];
                        новийБлокКоду.Операції.Add(зберіганняЦ);
                        новийБлокКоду.Операції.Add(зберіганняА);
                        новийБлокКоду.Операції.Add(умовнаОперація.Що);
                    }
                    else
                    {
                        for (int j = i + 3; j < блокКоду.Операції.Count; j++)
                        {
                            var операція2 = блокКоду.Операції[j];
                            новийБлокКоду.Операції.Add(ПерерахуватиІзА(операція2, а));
                        }

                        новийБлокКоду.Операції.Add(зберіганняЦ);
                        новийБлокКоду.Операції.Add(зберіганняА);
                    }

                    break;
                }

                if (i == блокКоду.Операції.Count - 2 
                    && операція is УмовнаОперація умовнаОпераціяВКінці 
                    && умовнаОпераціяВКінці.Умова is БінарнаОперація { Тип: ТипБінарноїОперації.Дорівнює } бінарнаОперація
                    && бінарнаОперація.Вираз1 is Регістр { регістр: ТипРегістра.Ц }
                    && бінарнаОперація.Вираз2 is Регістр { регістр: ТипРегістра.А })
                {
                    новийБлокКоду.Операції.Add(new УмовнаОперація(new БінарнаОперація(ТипБінарноїОперації.НеДорівнює, бінарнаОперація.Вираз1, бінарнаОперація.Вираз2), блокКоду.Операції[блокКоду.Операції.Count - 1]));
                    новийБлокКоду.Операції.Add(умовнаОпераціяВКінці.Що);
                    кінецьЦиклуЗнайден = true;
                    break;
                }
                else
                {
                    новийБлокКоду.Операції.Add(операція);
                }
            }

            if (кінецьЦиклуЗнайден)
            {
                var останняОперація = (Перехід)новийБлокКоду.Операції.Остання();
                var передостанняОперація = (Перехід)((УмовнаОперація)новийБлокКоду.Операції[новийБлокКоду.Операції.Count - 2]).Що;
                if (новийБлокКоду.ПочатковаАдреса == передостанняОперація.адреса && результат.БлокиКоду.Count > 1)
                {
                    var передостаннійБлок = результат.БлокиКоду[результат.БлокиКоду.Count - 2];
                    if (передостаннійБлок.Операції.Count >= 2 
                        && передостаннійБлок.Операції[передостаннійБлок.Операції.Count - 2] is ЗберіганняЗмінної зберіганняЦ && зберіганняЦ.МісцеЗберігання is Регістр { регістр: ТипРегістра.Ц }
                        && передостаннійБлок.Операції[передостаннійБлок.Операції.Count - 1] is ЗберіганняЗмінної зберіганняА && зберіганняА.МісцеЗберігання is Регістр { регістр: ТипРегістра.А })
                    {
                        передостаннійБлок.Операції.RemoveAt(передостаннійБлок.Операції.Count - 1);
                        передостаннійБлок.Операції.RemoveAt(передостаннійБлок.Операції.Count - 1);
                        var кінецьЦиклу = новийБлокКоду.Операції.Остання();
                        var блокЦиклу = new БлокОперацій(новийБлокКоду.Операції.Взяти(новийБлокКоду.Операції.Count - 3).ToArray());

                        var ц = ((Константа)зберіганняЦ.Що).значення;
                        var а = ((Константа)зберіганняА.Що).значення;
                        передостаннійБлок.Операції.Add(new Цикл(а, ц, блокЦиклу));
                        передостаннійБлок.Операції.Add(кінецьЦиклу);
                        результат.БлокиКоду.Remove(новийБлокКоду);
                        останнійОбробленийБлокКоду = передостаннійБлок;
                        continue;
                    }
                }

                останнійОбробленийБлокКоду = новийБлокКоду;
            }
        }

        return результат;
    }

    private static Лістінг НормалізуватиЛістінг(Лістінг лістінг)
    {
        List<int> точкиПереходу = new();
        foreach (var (лінія, адреса) in лістінг.ОдиниціКоду.ВибратиБагато(ок => ок.Команди.Вибрати((к, а) => (к, ок.ПочатковаАдреса + а))))
        {
            var команда = ПарсерКоманд.Розібрати(лінія);
            switch (команда.Код)
            {
                case КодОперації.СравнениеБезУчетаЗнаков:
                    точкиПереходу.Add(команда.Адреса3);
                    break;
                case КодОперації.СравнениеСУчетомЗнаков:
                    точкиПереходу.Add(команда.Адреса3);
                    break;
                case КодОперації.ТочноеСравнение:
                    точкиПереходу.Add(команда.Адреса3);
                    break;
                case КодОперації.ВыводКодов:
                    точкиПереходу.Add(команда.Адреса3);
                    break;
                case КодОперації.ЗаписьНаМагнитныйБарабанКодовИзЯчеекЗапоминающегоУстройств:
                    точкиПереходу.Add(команда.Адреса3);
                    break;
                case КодОперації.ЧтениеКодовСМагнитногоБарабанаВЯчейкиЗапоминающегоУстройства:
                    точкиПереходу.Add(команда.Адреса3);
                    break;
                case КодОперації.УсловныйПереходНаПодпрограмму:
                    точкиПереходу.Add(команда.Адреса2);
                    точкиПереходу.Add(команда.Адреса3);
                    break;
                case КодОперації.НачалоГрупповойОперации:
                    точкиПереходу.Add(команда.Адреса3);
                    break;
                case КодОперації.ОкончаниеГрупповойОперации:
                    точкиПереходу.Add(команда.Адреса2);
                    точкиПереходу.Add(команда.Адреса3);
                    break;
                case КодОперації.УсловныйПереходПоЗнакуЧисла:
                    точкиПереходу.Add(команда.Адреса2);
                    точкиПереходу.Add(команда.Адреса3);
                    break;
                default:
                    break;
            }
        }

        List<ОдиницяКоду> одиниціКоду = new();
        foreach (var одиницяКоду in лістінг.ОдиниціКоду)
        {
            БлокКоду блок = new БлокКоду(одиницяКоду.ПочатковаАдреса);
            for (int i = 0; i < одиницяКоду.Команди.Count; i++)
            {
                ulong команда = одиницяКоду.Команди[i];
                if (точкиПереходу.Contains(одиницяКоду.ПочатковаАдреса + i))
                {
                    if (блок.Операції.Count > 0)
                    {
                        лістінг.БлокиКоду.Add(блок);
                    }

                    блок = new БлокКоду(одиницяКоду.ПочатковаАдреса + i);
                }

                try
                {
                    var операції = ДоАссемблера(ПарсерКоманд.Розібрати(команда), true);
                    блок.Операції.AddRange(операції);
                }
                catch
                {
                    блок.Операції.Add(new НевідомаОперація(команда));
                }
            }

            лістінг.БлокиКоду.Add(блок);
        }

        return лістінг;
    }

    private static void НадрукуватиОперацію(ТекстовийПисарІзВиступами писар, Операція операція)
    {
        switch (операція)
        {
            case УмовнаОперація умовнаОперація:
                писар.WriteLine($"if ({умовнаОперація.Умова})");
                if (умовнаОперація.Що is БлокОперацій)
                {
                    писар.WriteLine("{");
                }

                писар.Відступ++;
                НадрукуватиОперацію(писар, умовнаОперація.Що);
                писар.Відступ--;
                if (умовнаОперація.Що is БлокОперацій)
                {
                    писар.WriteLine("}");
                }
                break;
            case УмовнаОперація2 умовнаОперація:
                писар.WriteLine($"if ({умовнаОперація.Умова})");
                if (умовнаОперація.Що is БлокОперацій)
                {
                    писар.WriteLine("{");
                }

                писар.Відступ++;
                НадрукуватиОперацію(писар, умовнаОперація.Що);
                писар.Відступ--;
                if (умовнаОперація.Що is БлокОперацій)
                {
                    писар.WriteLine("}");
                }

                писар.WriteLine($"else");
                if (умовнаОперація.Інакше is БлокОперацій)
                {
                    писар.WriteLine("{");
                }

                писар.Відступ++;
                НадрукуватиОперацію(писар, умовнаОперація.Інакше);
                писар.Відступ--;
                if (умовнаОперація.Інакше is БлокОперацій)
                {
                    писар.WriteLine("}");
                }
                break;
            case БлокОперацій блокОперацій:
                foreach (var оп in блокОперацій.Операції)
                    НадрукуватиОперацію(писар, оп);
                break;
            case Цикл цикл:
                писар.WriteLine($"for (А = {цикл.А}; А != {цикл.Ц}; А++)");
                писар.WriteLine("{");
                писар.Відступ++;
                НадрукуватиОперацію(писар, цикл.Операції);
                писар.Відступ--;
                писар.WriteLine("}");
                break;
            default:
                писар.WriteLine(операція.ToString());
                break;
        }
    }

    private static Операція ВставитиЗмінні(Операція операція)
    {
        return ПерезаписатиВирази(операція, ПерезаписатиАдреси);
        static Вираз ПерезаписатиАдреси(Вираз вираз)
        {
            return вираз switch
            {
                УнарнаОперація унарна => new УнарнаОперація(унарна.Тип, ПерезаписатиАдреси(унарна.Вираз)),
                БінарнаОперація бінарна => new БінарнаОперація(бінарна.Тип, ПерезаписатиАдреси(бінарна.Вираз1), ПерезаписатиАдреси(бінарна.Вираз2)),
                АдресаПамяти адресаПамяти => адресаПамяти.адреса switch
                {
                    Регістр => адресаПамяти,
                    Константа константа when константа.значення == Із8РічноїАдреси(0) => new Константа(0),

                    Константа константа when константа.значення == Із8РічноїАдреси(2) => new Ідентифікатор("парам"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3) => new Ідентифікатор("рез"),
                    Константа константа when константа.значення == Із8РічноїАдреси(4) => new Ідентифікатор("тимч1"),
                    Константа константа when константа.значення == Із8РічноїАдреси(5) => new Ідентифікатор("тимч2"),
                    Константа константа when константа.значення == Із8РічноїАдреси(6) => new Ідентифікатор("тимч3"),

                    Константа константа when константа.значення == Із8РічноїАдреси(3010) => new Ідентифікатор("ДваУМінус16Ступіні"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3011) => new Ідентифікатор("ДваУМінус28Ступіні"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3012) => new Ідентифікатор("ДваУМінус40Ступіні"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3017) => new Ідентифікатор("ДваУМінус15Ступіні"),

                    Константа константа when константа.значення == Із8РічноїАдреси(3020) => new Ідентифікатор("ДваУМінус27Ступіні"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3021) => new Ідентифікатор("ДваУМінус39Ступіні"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3025) => new Ідентифікатор("Мінус15_16их"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3026) => new Ідентифікатор("МінусНуль"),
                    
                    Константа константа when константа.значення == Із8РічноїАдреси(3035) => new Ідентифікатор("МашиннаОдиниця"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3036) => new Ідентифікатор("МінусМашиннаОдиниця"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3037) => new Ідентифікатор("Log10_2"),

                    Константа константа when константа.значення == Із8РічноїАдреси(3040) => new Ідентифікатор("ДваУМінус12Ступіні"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3041) => new Ідентифікатор("ДваУМінус24Ступіні"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3042) => new Ідентифікатор("ДваУМінус1Ступіні"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3043) => new Ідентифікатор("ДваУМінус2Ступіні"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3044) => new Ідентифікатор("ДваУМінус3Ступіні"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3045) => new Ідентифікатор("ДваУМінус4Ступіні"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3046) => new Ідентифікатор("ДваУМінус6Ступіні"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3047) => new Ідентифікатор("ДваУМінус36Ступіні"),

                    Константа константа when константа.значення == Із8РічноїАдреси(3050) => new Ідентифікатор("Плюс10_16их"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3051) => new Ідентифікатор("Ln2"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3052) => new Ідентифікатор("ОднаДесята"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3053) => new Ідентифікатор("ОднаСота"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3054) => new Ідентифікатор("ОднаТисячна"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3055) => new Ідентифікатор("ДвіДесятих"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3056) => new Ідентифікатор("ТриДесятих"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3057) => new Ідентифікатор("ВісімДесятих"),

                    Константа константа when константа.значення == Із8РічноїАдреси(3060) => new Ідентифікатор("ДвіТисячних"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3061) => new Ідентифікатор("ШіснадцятьСотих"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3062) => new Ідентифікатор("ТридьцятьДвіСотих"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3063) => new Ідентифікатор("ОдиницяНаПі"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3064) => new Ідентифікатор("ОдиницяНаКоріньІзПі"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3065) => new Ідентифікатор("ОдиницяНаЕ"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3066) => new Ідентифікатор("ПіНаЧотири"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3067) => new Ідентифікатор("ДваНаПі"),

                    Константа константа when константа.значення == Із8РічноїАдреси(3070) => new Ідентифікатор("КоріньДвійкиНаДва"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3071) => new Ідентифікатор("ОдинНаКоріньІзТрьох"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3072) => new Ідентифікатор("ЕНаТри"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3073) => new Ідентифікатор("ОдинНаКоріньІзДваПі"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3074) => new Ідентифікатор("ЕНаЧотири"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3075) => new Ідентифікатор("ОднаТретя"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3076) => new Ідентифікатор("ОдинНаПіКвадрат"),
                    Константа константа when константа.значення == Із8РічноїАдреси(3077) => new Ідентифікатор("Lg_E"),
                    _ => адресаПамяти
                },
                _ => вираз,
            };
        }
    }

    private static Операція ПерерахуватиІзА(Операція операція, int а)
    {
        return ПерезаписатиВирази(операція, ПерезаписатиАдреси);
        Вираз ПерезаписатиАдреси(Вираз вираз)
        {
            return вираз switch
            {
                УнарнаОперація унарна => new УнарнаОперація(унарна.Тип, ПерезаписатиАдреси(унарна.Вираз)),
                БінарнаОперація бінарна => new БінарнаОперація(бінарна.Тип, ПерезаписатиАдреси(бінарна.Вираз1), ПерезаписатиАдреси(бінарна.Вираз2)),
                АдресаПамяти адресаПамяти => адресаПамяти.адреса switch
                {
                    Регістр регістр when регістр.регістр == ТипРегістра.А => new Константа(а),
                    _ => адресаПамяти
                },
                _ => вираз,
            };
        }
    }
    private static Операція ПерезаписатиВирази(Операція операція, Func<Вираз, Вираз> перезаписувач)
    {
        switch (операція)
        {
            case ЗберіганняЗмінної зберіганняЗмінної:
                return new ЗберіганняЗмінної(перезаписувач(зберіганняЗмінної.МісцеЗберігання), перезаписувач(зберіганняЗмінної.Що));
            case УмовнаОперація умовнаОперація:
                return new УмовнаОперація(перезаписувач(умовнаОперація.Умова), ПерезаписатиВирази(умовнаОперація.Що, перезаписувач));
            case УмовнаОперація2 умовнаОперація:
                return new УмовнаОперація2(перезаписувач(умовнаОперація.Умова), ПерезаписатиВирази(умовнаОперація.Що, перезаписувач), ПерезаписатиВирази(умовнаОперація.Інакше, перезаписувач));
            case БлокОперацій двіОперації:
                return new БлокОперацій(двіОперації.Операції.Вибрати(о => ПерезаписатиВирази(о, перезаписувач)).ДоМасиву());
            case Перехід:
            case Повернутися:
            case ВстановитиТочкуПовернення:
            case ВвідЧисел:
            case ВвідКодів:
            case ВивідКодів:
            case ЗаписатиКодаНаБарабан:
            case ПрочитатиКодаІзБарабана:
            case ПідготуватиБарабан:
            case Стоп:
            case НевідомаОперація:
                return операція;
            default:
                throw new NotSupportedException($"Операція {операція} не підтримується");
        }
    }

    private static IEnumerable<Операція> ДоАссемблера(СтруктураКоманди команда, bool html)
    {
        switch (команда.Код)
        {
            case КодОперації.Сложение:
                yield return СтворитиБінарнуОперацію(ТипБінарноїОперації.Додавання, команда);
                break;
            case КодОперації.Вычитание:
                yield return СтворитиБінарнуОперацію(ТипБінарноїОперації.Віднімання, команда);
                break;
            case КодОперації.СложениеКоманд:
                yield return СтворитиБінарнуОперацію(ТипБінарноїОперації.ДодаванняКоманд, команда);
                break;
            case КодОперації.СравнениеСУчетомЗнаков:
                yield return new УмовнаОперація(
                    new БінарнаОперація(ТипБінарноїОперації.МеншеЧиДорівнює,
                        ВідноснаПамять(команда.Адреса1),
                        ВідноснаПамять(команда.Адреса2)),
                    new Перехід(команда.Адреса3));
                break;
            case КодОперації.СравнениеБезУчетаЗнаков:
                yield return new УмовнаОперація(
                    new БінарнаОперація(ТипБінарноїОперації.МеншеЧиДорівнює,
                        new УнарнаОперація(ТипУнарноїОперації.Модуль, ВідноснаПамять(команда.Адреса1)),
                        new УнарнаОперація(ТипУнарноїОперації.Модуль, ВідноснаПамять(команда.Адреса2))),
                    new Перехід(команда.Адреса3));
                break;
            case КодОперації.ВычитаниеПоМодулю:
                yield return new ЗберіганняЗмінної(
                    ВідноснаПамять(команда.Адреса3),
                    new БінарнаОперація(ТипБінарноїОперації.Віднімання,
                        new УнарнаОперація(ТипУнарноїОперації.Модуль, ВідноснаПамять(команда.Адреса1)),
                        new УнарнаОперація(ТипУнарноїОперації.Модуль, ВідноснаПамять(команда.Адреса2))));
                break;
            case КодОперації.ЦиклическоеСложение:
                yield return СтворитиБінарнуОперацію(ТипБінарноїОперації.ЦиклічнеДодавання, команда);
                break;
            case КодОперації.УмножениеБезОкругления:
                yield return СтворитиБінарнуОперацію(ТипБінарноїОперації.МноженняБезСкругленням, команда);
                break;
            case КодОперації.УмножениеСОкруглением:
                yield return СтворитиБінарнуОперацію(ТипБінарноїОперації.Множення, команда);
                break;
            case КодОперації.Деление:
                yield return СтворитиБінарнуОперацію(ТипБінарноїОперації.Ділення, команда);
                break;
            case КодОперації.ЛогическийСдвиг:
                yield return new УмовнаОперація2(
                    new БінарнаОперація(ТипБінарноїОперації.МеншеЧиДорівнює,
                        ВідноснаПамять(команда.Адреса1),
                        new Константа(0)),
                    new ЗберіганняЗмінної(
                        ВідноснаПамять(команда.Адреса3),
                        new БінарнаОперація(ТипБінарноїОперації.СдвигВправо, ВідноснаПамять(команда.Адреса1), new УнарнаОперація(ТипУнарноїОперації.Модуль, ВідноснаПамять(команда.Адреса2)))),
                    new ЗберіганняЗмінної(
                        ВідноснаПамять(команда.Адреса3),
                        new БінарнаОперація(ТипБінарноїОперації.СдвигВліво, ВідноснаПамять(команда.Адреса1), ВідноснаПамять(команда.Адреса2))));
                break;
            case КодОперації.ЛогическоеСложение:
                yield return СтворитиБінарнуОперацію(ТипБінарноїОперації.ЛогічнеДодавання, команда);
                break;
            case КодОперації.ЛогическоеУмножение:
                yield return СтворитиБінарнуОперацію(ТипБінарноїОперації.ЛогічнеМноження, команда);
                break;
            case КодОперації.ТочноеСравнение:
                yield return new УмовнаОперація(
                    new БінарнаОперація(ТипБінарноїОперації.Дорівнює, ВідноснаПамять(команда.Адреса1), ВідноснаПамять(команда.Адреса2)),
                    new Перехід(команда.Адреса3));
                break;
            case КодОперації.ОперацияРавнозначно:
                yield return new ЗберіганняЗмінної(
                    ВідноснаПамять(команда.Адреса3),
                    new БінарнаОперація(ТипБінарноїОперації.ЛогічнеМноження, new УнарнаОперація(ТипУнарноїОперації.БітовеНі, СтворитиБінарнийВираз(ТипБінарноїОперації.ЛогічнаВиключнеАбо, команда)), new Число(ulong.MaxValue >> 23)));
                break;
            case КодОперації.ВводЧисел:
                yield return new ВвідЧисел(команда.Адреса1, команда.Адреса2);
                yield return new Перехід(команда.Адреса3);
                break;
            case КодОперації.ВводКоманд:
                yield return new ВвідКодів(команда.Адреса1, команда.Адреса2);
                yield return new Перехід(команда.Адреса3);
                break;
            case КодОперації.ВыводКодов:
                yield return new ВивідКодів(команда.Адреса1, команда.Адреса2);
                yield return new Перехід(команда.Адреса3);
                break;
            case КодОперації.ЗаписьНаМагнитныйБарабанКодовИзЯчеекЗапоминающегоУстройств:
                yield return new ЗаписатиКодаНаБарабан(команда.Адреса1, команда.Адреса2);
                yield return new Перехід(команда.Адреса3);
                break;
            case КодОперації.ЧтениеКодовСМагнитногоБарабанаВЯчейкиЗапоминающегоУстройства:
                yield return new ПрочитатиКодаІзБарабана(команда.Адреса1, команда.Адреса2);
                yield return new Перехід(команда.Адреса3);
                break;
            case КодОперації.ОбращениеКМагнитномуБарабану:
                yield return new ПідготуватиБарабан(команда.Адреса1, команда.Адреса2, команда.Адреса3);
                break;
            case КодОперації.НачалоГрупповойОперации:
                yield return new ЗберіганняЗмінної(
                    new Регістр(ТипРегістра.Ц),
                    ВідноснаАдреса(команда.Адреса1));
                yield return new ЗберіганняЗмінної(
                    new Регістр(ТипРегістра.А),
                    ВідноснаАдреса(команда.Адреса2));
                yield return new УмовнаОперація(
                    new БінарнаОперація(ТипБінарноїОперації.Дорівнює, new Регістр(ТипРегістра.Ц), new Регістр(ТипРегістра.А)),
                    new Перехід(команда.Адреса3));
                break;
            case КодОперації.ОкончаниеГрупповойОперации:
                yield return new ЗберіганняЗмінної(
                    new Регістр(ТипРегістра.А),
                    new БінарнаОперація(ТипБінарноїОперації.Додавання, new Регістр(ТипРегістра.А), new Константа(БазоваАдреса(команда.Адреса1))));
                yield return new УмовнаОперація(
                    new БінарнаОперація(ТипБінарноїОперації.Дорівнює, new Регістр(ТипРегістра.Ц), new Регістр(ТипРегістра.А)),
                    new Перехід(команда.Адреса3));
                yield return new Перехід(команда.Адреса2);
                break;
            case КодОперації.УсловныйПереходНаПодпрограмму:
                yield return new УмовнаОперація(
                    new БінарнаОперація(ТипБінарноїОперації.МеншеЧиДорівнює,
                        ВідноснаПамять(команда.Адреса1),
                        new Константа(0)),
                    new БлокОперацій([new ВстановитиТочкуПовернення(команда.Адреса2), new Перехід(команда.Адреса3)]));
                break;
            case КодОперації.УсловныйПереходПоЗнакуЧисла:
                yield return new УмовнаОперація(
                    new БінарнаОперація(ТипБінарноїОперації.МеншеЧиДорівнює,
                        ВідноснаПамять(команда.Адреса1),
                        new Константа(0)),
                    new Перехід(команда.Адреса3));
                yield return new Перехід(команда.Адреса2);
                break;
            case КодОперації.ПереходПоРегиструВозврата:
                yield return new Повернутися();
                break;
            case КодОперації.ОстановМашины:
                yield return new Стоп();
                break;
            case КодОперації.ПереходПоФиксатору:
                yield return new ЗберіганняЗмінної(
                    new Регістр(ТипРегістра.А),
                    ВідноснаПамять(команда.Адреса1));
                yield return new ЗберіганняЗмінної(
                    ВідноснаПамять(команда.Адреса3),
                    new АдресаПамяти(new Регістр(ТипРегістра.А)));
                break;
            default:
                throw new NotSupportedException($"Операція {команда.Код} не підтримується");
        }
    }

    private static Операція СтворитиБінарнуОперацію(ТипБінарноїОперації тип, СтруктураКоманди команда)
    {
        return new ЗберіганняЗмінної(
            ВідноснаПамять(команда.Адреса3),
            СтворитиБінарнийВираз(тип, команда));
    }

    private static Вираз СтворитиБінарнийВираз(ТипБінарноїОперації тип, СтруктураКоманди команда)
    {
        return new БінарнаОперація(тип, ВідноснаПамять(команда.Адреса1), ВідноснаПамять(команда.Адреса2));
    }

    private static Вираз ВідноснаАдреса(int адреса)
    {
        var базоваАдреса = БазоваАдреса(адреса);
        if ((адреса & (1 << 11)) != 0)
        {
            return new БінарнаОперація(ТипБінарноїОперації.Додавання, new Константа(базоваАдреса), new Регістр(ТипРегістра.А));
        }

        return new Константа(базоваАдреса);
    }

    private static int БазоваАдреса(int адреса)
    {
        var базоваАдреса = адреса & 0x7FF;
        return базоваАдреса;
    }

    private static АдресаПамяти ВідноснаПамять(int адреса)
    {
        return new АдресаПамяти(ВідноснаАдреса(адреса));
    }
}
